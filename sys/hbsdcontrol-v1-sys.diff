diff --git a/sys/amd64/conf/HARDENEDBSD b/sys/amd64/conf/HARDENEDBSD
index c9d7717eeee8..68218810c9bd 100644
--- a/sys/amd64/conf/HARDENEDBSD
+++ b/sys/amd64/conf/HARDENEDBSD
@@ -84,6 +84,9 @@ options 	RCTL			# Resource limits
 
 # HardenedBSD hardening options
 options 	PAX			# PaX framework
+options 	PAX_ACL			# PaX MAC framework, required for secadm
+options 	PAX_OVERRIDE_WITH_ACL	# this allows a fully functional secadm
+options 	PAX_HBSDCONTROL		# HardenedBSD's internal control utility's interface
 options 	PAX_SYSCTLS		# sysctls for run-time options
 options 	PAX_ASLR		# Address Space Layout Randomization
 options 	PAX_NOEXEC		# Remove WX pages from user-space and enforce W^X
diff --git a/sys/amd64/conf/OP-HBSD b/sys/amd64/conf/OP-HBSD
index 573c0e921439..041372bc9f1a 100644
--- a/sys/amd64/conf/OP-HBSD
+++ b/sys/amd64/conf/OP-HBSD
@@ -85,6 +85,7 @@ options 	RCTL			# Resource limits
 
 # HardenedBSD hardening options
 options 	PAX
+options 	PAX_HBSDCONTROL		# FS-EA based control framework
 options 	PAX_SYSCTLS		# sysctls for run-time options
 options 	PAX_ASLR		# Address Space Layout Randomization
 options 	PAX_NOEXEC		# Remove WX pages from user-space and enforce W^X
diff --git a/sys/conf/NOTES b/sys/conf/NOTES
index d7ae0d9d4eeb..4c0e19c39e0f 100644
--- a/sys/conf/NOTES
+++ b/sys/conf/NOTES
@@ -3024,6 +3024,9 @@ options 	GZIO
 
 # PAX and HardenedBSD related knobs
 options 	PAX		# Enable the PAX framework
+options 	PAX_ACL		# PaX MAC framework, required for secadm
+options 	PAX_OVERRIDE_WITH_ACL	# this allows a fully functional secadm
+options 	PAX_HBSDCONTROL	# FS-EA based control framework
 options 	PAX_ASLR	# Address Space Layout Randomization
 options 	PAX_HARDENING	# Other hardening features
 options 	PAX_NOEXEC	# Remove WX pages from user-space and enforce W^X
diff --git a/sys/conf/files b/sys/conf/files
index 2ffd63fbbbb6..e61e7285abe6 100644
--- a/sys/conf/files
+++ b/sys/conf/files
@@ -3533,6 +3533,7 @@ hardenedbsd/hbsd_pax_aslr.c		optional pax pax_aslr
 hardenedbsd/hbsd_pax_hardening.c	optional pax pax_hardening
 hardenedbsd/hbsd_pax_noexec.c		optional pax pax_noexec
 hardenedbsd/hbsd_pax_segvguard.c	optional pax pax_segvguard
+hardenedbsd/hbsd_hbsdcontrol.c		optional pax pax_hbsdcontrol
 #
 isa/isa_if.m			standard
 isa/isa_common.c		optional isa
@@ -4597,7 +4598,7 @@ security/mac/mac_cred.c		optional mac
 security/mac/mac_framework.c	optional mac
 security/mac/mac_inet.c		optional mac inet | mac inet6
 security/mac/mac_inet6.c	optional mac inet6
-security/mac/mac_jail.c		optional mac
+security/mac/mac_jail.c		optional mac pax_acl
 security/mac/mac_label.c	optional mac
 security/mac/mac_net.c		optional mac
 security/mac/mac_pipe.c		optional mac
diff --git a/sys/conf/options b/sys/conf/options
index 34702652cf5d..2cba4532c69b 100644
--- a/sys/conf/options
+++ b/sys/conf/options
@@ -972,6 +972,9 @@ PAX_SEGVGUARD	opt_pax.h
 PAX_HARDENING	opt_pax.h
 PAX_NOEXEC	opt_pax.h
 PAX_INSECURE_MODE	opt_pax.h
+PAX_HBSDCONTROL	opt_pax.h
+PAX_ACL		opt_pax.h
+PAX_OVERRIDE_WITH_ACL	opt_pax.h
 HBSD_DEBUG	opt_pax.h
 
 # ASLR overwritable defaults
diff --git a/sys/hardenedbsd/hbsd_hbsdcontrol.c b/sys/hardenedbsd/hbsd_hbsdcontrol.c
new file mode 100644
index 000000000000..b151c17993a4
--- /dev/null
+++ b/sys/hardenedbsd/hbsd_hbsdcontrol.c
@@ -0,0 +1,291 @@
+/*-
+ * Copyright (c) 2015-2017 Oliver Pinter <oliver.pinter@HardenedBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD$
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include "opt_pax.h"
+
+#include <sys/param.h>
+#include <sys/systm.h>
+#include <sys/kernel.h>
+#include <sys/extattr.h>
+#include <sys/fcntl.h>
+#include <sys/imgact.h>
+#include <sys/imgact_elf.h>
+#include <sys/ktr.h>
+#include <sys/libkern.h>
+#include <sys/limits.h>
+#include <sys/namei.h>
+#include <sys/pax.h>
+#include <sys/proc.h>
+#include <sys/stat.h>
+#include <sys/sysctl.h>
+#include <sys/uio.h>
+#include <sys/vnode.h>
+
+FEATURE(hbsdcontrol, "HardenedBSD's FS-EA based control subsystem.");
+
+static int pax_hbsdcontrol_status = PAX_FEATURE_SIMPLE_ENABLED;
+TUNABLE_INT("hardening.hbsdcontrol.status", &pax_hbsdcontrol_status);
+
+static bool pax_hbsdcontrol_active(void);
+
+struct pax_feature_entry {
+	const char		*fs_ea_attribute;
+	const pax_flag_t	 feature_bit;
+};
+
+const struct pax_feature_entry pax_features[] = {
+	{"hbsd.pax.aslr",			PAX_NOTE_ASLR},
+	{"hbsd.pax.noaslr",			PAX_NOTE_NOASLR},
+	{"hbsd.pax.segvguard",			PAX_NOTE_SEGVGUARD},
+	{"hbsd.pax.nosegvguard",		PAX_NOTE_NOSEGVGUARD},
+	{"hbsd.pax.pageexec",			PAX_NOTE_PAGEEXEC},
+	{"hbsd.pax.nopageexec",			PAX_NOTE_NOPAGEEXEC},
+	{"hbsd.pax.mprotect",			PAX_NOTE_MPROTECT},
+	{"hbsd.pax.nomprotect",			PAX_NOTE_NOMPROTECT},
+	{"hbsd.pax.shlibrandom",		PAX_NOTE_SHLIBRANDOM},
+	{"hbsd.pax.noshlibrandom",		PAX_NOTE_NOSHLIBRANDOM},
+	{"hbsd.pax.disallow_map32bit",		PAX_NOTE_DISALLOWMAP32BIT},
+	{"hbsd.pax.nodisallow_map32bit",	PAX_NOTE_NODISALLOWMAP32BIT},
+	{NULL, 0}
+};
+
+#ifdef PAX_SYSCTLS
+SYSCTL_DECL(_hardening_pax);
+
+SYSCTL_NODE(_hardening_pax, OID_AUTO, hbsdcontrol, CTLFLAG_RD, 0,
+    "FS-EA based control subsystem.");
+
+SYSCTL_INT(_hardening_pax_hbsdcontrol, OID_AUTO, status,
+    CTLFLAG_RDTUN|CTLFLAG_SECURE,
+    &pax_hbsdcontrol_status, 0,
+    "status: "
+    "0 - disabled, "
+    "1 - enabled");
+#endif /* PAX_SYSCTLS */
+
+uint32_t
+pax_hbsdcontrol_parse_fsea_flags(struct thread *td, struct image_params *imgp, pax_flag_t *flags)
+{
+	struct uio uio;
+	struct iovec iov;
+	unsigned char feature_status;
+	bool feature_present[nitems(pax_features)];
+	unsigned char *fsea_list;
+	size_t fsea_list_size;
+	size_t fsea_attrname_len;
+	pax_flag_t parsed_flags;
+	unsigned char entry_size;
+	int i, j;
+	int error;
+
+	if (!pax_hbsdcontrol_active()) {
+		*flags = 0;
+		return (0);
+	}
+
+	feature_status = 0;
+	fsea_list = NULL;
+	fsea_list_size = 0;
+	fsea_attrname_size = 0;
+	parsed_flags = 0;
+
+	for (i = 0; i < nitems(feature_present); i++)
+		feature_present[i] = false;
+
+	/* Query the size of extended attribute names list. */
+	error = VOP_LISTEXTATTR(imgp->vp, EXTATTR_NAMESPACE_SYSTEM, NULL,
+	    &fsea_list_size, NULL, td);
+
+	/*
+	 *  Fast path:
+	 *   - FS-EA not supported by the FS, or
+	 *   - other error, or
+	 *   - no FS-EA assigned for the file.
+	 */
+	if (error != 0 || fsea_list_size == 0)
+		goto out;
+
+	if (fsea_list_size > IOSIZE_MAX) {
+		error = ENOMEM;
+		goto out;
+	}
+
+	fsea_list = malloc(fsea_list_size, M_TEMP, M_WAITOK|M_ZERO);
+
+	memset(&uio, 0, sizeof(uio));
+	memset(&iov, 0, sizeof(iov));
+	iov.iov_base = fsea_list;
+	iov.iov_len = fsea_list_size;
+	uio.uio_iov = &iov;
+	uio.uio_iovcnt = 1;
+	uio.uio_offset = 0;
+	uio.uio_rw = UIO_READ;
+	uio.uio_segflg = UIO_SYSSPACE;
+	uio.uio_td = td;
+	uio.uio_resid = fsea_list_size;
+
+	/* Query the FS-EA list. */
+	error = VOP_LISTEXTATTR(imgp->vp, EXTATTR_NAMESPACE_SYSTEM, &uio, NULL, NULL, td);
+	if (error != 0)
+		goto out;
+
+	/*
+	 * Create a filter from existing hbsd.pax attributes.
+	 */
+	for (i = 0; i < fsea_list_size; ) {
+		/* See VOP_LISTEXTATTR(9) for the details. */
+		entry_size = fsea_list[i++];
+
+		for (j = 0; pax_features[j].fs_ea_attribute != NULL; j++) {
+			fsea_attrname_len = strlen(pax_features[j].fs_ea_attribute);
+
+			/* 
+			 * Fast path:
+			 * compare the string's len without the the ending zero
+			 * with the attribute name stored without zero.
+			 */
+			if (fsea_attrname_len != entry_size)
+				break;
+
+			/*
+			 * Compare the strings as byte arrays without the ending zeros
+			 * after we checked its lengths.
+			 */
+			if (memcmp(pax_features[j].fs_ea_attribute, &fsea_list[i],
+			    fsea_attrname_len) == 0) {
+				feature_present[j] = true;
+				/*
+				 * Once we found the relevant enty,
+				 * start over a new round for a new entry.
+				 */
+				break;
+			}
+		}
+		i += entry_size;
+	}
+
+	for (i = 0; pax_features[i].fs_ea_attribute != NULL; i++) {
+		if (feature_present[i] == false)
+			continue;
+
+		memset(&uio, 0, sizeof(uio));
+		memset(&iov, 0, sizeof(iov));
+		feature_status = 0;
+
+		iov.iov_base = &feature_status;
+		iov.iov_len = sizeof(feature_status);
+		uio.uio_iov = &iov;
+		uio.uio_iovcnt = 1;
+		uio.uio_offset = 0;
+		uio.uio_rw = UIO_READ;
+		uio.uio_segflg = UIO_SYSSPACE;
+		uio.uio_td = td;
+		uio.uio_resid = sizeof(feature_status);
+
+		/*
+		 * Use NOCRED as credential to always get the extended attributes,
+		 * even if the user execs a program.
+		 */
+		error = VOP_GETEXTATTR(imgp->vp, EXTATTR_NAMESPACE_SYSTEM,
+		    pax_features[i].fs_ea_attribute, &uio, NULL, NOCRED, td);
+
+		if (error == 0) {
+			switch (feature_status) {
+			case '0':
+				parsed_flags &= ~pax_features[i].feature_bit;
+				break;
+			case '1':
+				parsed_flags |= pax_features[i].feature_bit;
+				break;
+			default:
+				printf("%s: unknown state: %c [0x%x]\n",
+				    pax_features[i].fs_ea_attribute,
+				    feature_status, feature_status);
+				break;
+			}
+		} else {
+			switch (error) {
+			case ENOATTR:
+				/* Ignore non-existing attribute error. */
+				break;
+			default:
+				/*
+				 * For other errors, reset the parsed_flags
+				 * and use the system defaults.
+				 */
+				goto out;
+			}
+		}
+	}
+
+out:
+	free(fsea_list, M_TEMP);
+
+	/* In case of error, reset to the system defaults. */
+	if (error)
+		parsed_flags = 0;
+
+	*flags = parsed_flags;
+
+	return (0);
+}
+
+static bool
+pax_hbsdcontrol_active(void)
+{
+
+	if ((pax_hbsdcontrol_status & PAX_FEATURE_SIMPLE_ENABLED) == PAX_FEATURE_SIMPLE_ENABLED)
+		return (true);
+
+	if ((pax_hbsdcontrol_status & PAX_FEATURE_SIMPLE_DISABLED) == PAX_FEATURE_SIMPLE_DISABLED)
+		return (false);
+
+	return (true);
+}
+
+static void
+pax_hbsdcontrol_sysinit(void)
+{
+
+	switch (pax_hbsdcontrol_status) {
+	case PAX_FEATURE_SIMPLE_DISABLED:
+	case PAX_FEATURE_SIMPLE_ENABLED:
+		break;
+	default:
+		printf("[HBSD CONTROL] WARNING, invalid settings in loader.conf!"
+		    " (pax_hbsdcontrol_status = %d)\n", pax_hbsdcontrol_status);
+		pax_hbsdcontrol_status = PAX_FEATURE_SIMPLE_ENABLED;
+		break;
+	}
+	printf("[HBSD CONTROL] status: %s\n", pax_status_simple_str[pax_hbsdcontrol_status]);
+}
+SYSINIT(pax_hbsdcontrol, SI_SUB_PAX, SI_ORDER_SECOND, pax_hbsdcontrol_sysinit, NULL);
+
diff --git a/sys/hardenedbsd/hbsd_pax_common.c b/sys/hardenedbsd/hbsd_pax_common.c
index 31607d941c23..cbf3ae8d70e8 100644
--- a/sys/hardenedbsd/hbsd_pax_common.c
+++ b/sys/hardenedbsd/hbsd_pax_common.c
@@ -254,10 +254,20 @@ pax_check_conflicting_modes(const pax_flag_t mode)
  * 			0 on success
  */
 int
-pax_elf(struct image_params *imgp, struct thread *td, pax_flag_t mode)
+pax_elf(struct thread *td, struct image_params *imgp, pax_flag_t mode)
 {
 	pax_flag_t flags;
 
+#ifdef PAX_ACL
+#ifdef PAX_OVERRIDE_WITH_ACL
+	pax_get_flags_td(td, &flags);
+	if ((flags & PAX_NOTE_FINALIZED) == PAX_NOTE_FINALIZED)
+		return (0);
+#endif
+#endif
+
+	flags = 0;
+
 	if (pax_validate_flags(mode) != 0) {
 		pax_log_internal_imgp(imgp, PAX_LOG_DEFAULT,
 		    "unknown paxflags: %x", mode);
@@ -277,8 +287,6 @@ pax_elf(struct image_params *imgp, struct thread *td, pax_flag_t mode)
 		return (ENOEXEC);
 	}
 
-	flags = 0;
-
 #ifdef PAX_ASLR
 	flags |= pax_aslr_setup_flags(imgp, td, mode);
 #ifdef MAP_32BIT
diff --git a/sys/kern/kern_exec.c b/sys/kern/kern_exec.c
index 3c910390d9af..b6567614afb7 100644
--- a/sys/kern/kern_exec.c
+++ b/sys/kern/kern_exec.c
@@ -383,6 +383,9 @@ do_execve(td, args, mac_p)
 	struct pmckern_procexec pe;
 #endif
 	static const char fexecv_proc_title[] = "(fexecv)";
+#ifdef PAX
+	pax_flag_t pax_settings = 0;
+#endif
 
 	imgp = &image_params;
 
@@ -462,12 +465,6 @@ interpret:
 		imgp->vp = newtextvp;
 	}
 
-#ifdef PAX
-	error = pax_elf(imgp, td, 0);
-	if (error)
-		goto exec_fail_dealloc;
-#endif
-
 	/*
 	 * Check file permissions (also 'opens' file)
 	 */
@@ -475,6 +472,19 @@ interpret:
 	if (error)
 		goto exec_fail_dealloc;
 
+#ifdef PAX_HBSDCONTROL
+	error = pax_hbsdcontrol_parse_fsea_flags(td, imgp, &pax_settings);
+	if (error)
+		goto exec_fail_dealloc;
+#endif
+
+#ifdef PAX
+	error = pax_elf(td, imgp, pax_settings);
+	if (error) {
+		goto exec_fail_dealloc;
+	}
+#endif
+
 	imgp->object = imgp->vp->v_object;
 	if (imgp->object != NULL)
 		vm_object_reference(imgp->object);
diff --git a/sys/kern/kern_jail.c b/sys/kern/kern_jail.c
index 9d13fe67fa46..e0031a80bc8d 100644
--- a/sys/kern/kern_jail.c
+++ b/sys/kern/kern_jail.c
@@ -2287,8 +2287,10 @@ prison_remove_one(struct prison *pr)
 	int deuref;
 
 #ifdef MAC
+#ifdef PAX_ACL
 	mac_prison_destroy(pr);
 #endif
+#endif
 
 	/* If the prison was persistent, it is not anymore. */
 	deuref = 0;
diff --git a/sys/sys/pax.h b/sys/sys/pax.h
index 531175593f4f..0746519d1a0a 100644
--- a/sys/sys/pax.h
+++ b/sys/sys/pax.h
@@ -93,7 +93,7 @@ extern const char *pax_status_simple_str[];
  * generic pax functions
  */
 uint64_t pax_get_hardenedbsd_version(void);
-int pax_elf(struct image_params *imgp, struct thread *td, pax_flag_t mode);
+int pax_elf(struct thread *td, struct image_params *imgp, pax_flag_t mode);
 void pax_get_flags(struct proc *p, pax_flag_t *flags);
 void pax_get_flags_td(struct thread *td, pax_flag_t *flags);
 struct prison *pax_get_prison(struct proc *p);
@@ -101,6 +101,11 @@ struct prison *pax_get_prison_td(struct thread *td);
 void pax_init_prison(struct prison *pr);
 
 /*
+ * HardenedBSD's hbsdcontol related functions
+ */
+pax_flag_t pax_hbsdcontrol_parse_fsea_flags(struct thread *td, struct image_params *imgp, pax_flag_t *flags);
+
+/*
  * ASLR related functions
  */
 bool pax_aslr_active(struct proc *p);
